## 집계

- COUNT - 행 개수
  - `*` 를 인수로 사용할 수 있다.
  - NULL 값이 있을 경우 이를 제외하고 처리한다.
  - DISTINCT 키워드로 중복 제거
- SUM - 합계
  - 수치형만 (문자열형, 날짜시간형 X)
  - NULL 값 무시 - NULL 제외한 합계
- AVG - 평균
  - NULL 무시 - NULL 제외한 평균
  - CASE를 사용해서 NULL -> 0 으로 변환하여 계산할 수도 있다.
- MIN - 최소, MAX - 최대
  - 문자열형과 날짜시간형에도 사용할 수 있다.
  - NULL 무시



## GROUP BY

GROUP BY 구를 사용해 집계함수로 넘겨줄 집합을 그룹으로 나눈다.

지정된 열의 값이 같은 행이 하나의 그룹으로 묶인다.

GROUP BY 구를 지정하는 경우에는 집계함수와 함께 사용하지 않으면 별 의미가 없다. GROUP BY 구로 그룹화된 각각의 그룹이 하나의 집합으로서 집계함수의 인수로 넘겨지기 때문이다.

WHERE 구에서는 집계함수를 사용할 수 없다.

집계함수를 사용할 경우 HAVING 구로 검색조건을 지정한다.

```
# 내부 처리 순서
WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY
```

GROUP BY에 지정한 열 이외의 열은 집계함수를 사용하지 않은 채 SELECT 구에 기술해서는 안된다.

결괏값을 순서대로 정렬해야 한다면 ORDER BY 구를 지정한다.



## 서브쿼리

SELECT 명령에 대한 데이터 질의. 상부가 아닌 하부의 부수적인 질의를 이미한다.

괄호로 묶어서 지정한다.

SELECT, FROM, WHERE -> WHERE 에서 주로 사용된다.

SELECT, DELETE, UPDATE 에서 서브쿼리 사용할 수 있다.

```sql
-- MySQL에 한해 변수 사용
set @a = (SELECT MIN(a) from sample);
DELETE FROM sample WHERE a = @a;
```

>  MySQL에서는 데이터를 추가하거나 갱신할 경우 동일한 테이블을 서브쿼리에서 사용할 수 없도록 되어있다. -> 인라인 뷰 사용

### 

SELECT 명령이 하나의 값만 반환하는 것을 '스칼라 값을 반환한다'고 한다.

스칼라 값을 반환하는 SELECT 명령을 특별 취급 -> 서브쿼리로서 사용하기 쉽기 때문

WHERE에서 스칼라 값을 반환하는 서브쿼리는 = 연산자로 비교할 수 있다는 뜻이다.

스칼라 서브쿼리는 WHERE 구에 사용할 수 있으므로 집계함수를 사용해 집계한 결과를 조건식으로 사용할 수 있다.

SELECT 구에서 서브쿼리를 지정할 때는 스칼라 서브쿼리가 필요하다.

UPDATE SET 구에서 서브쿼리 사용할 경우에 스칼라 서브쿼리를 지정할 필요가 있다.

FROM 구에 기술할 경우에는 스칼라 값을 반환하지 않아도 좋다.(스칼라 값도 상관없다.)

AS 키워드를 사용하여 테이블이나 서브쿼리에 별명을 붙일 수 있다.

INSERT 명령에 VALUES 구 대신에 SELECT 명령 사용하는 것 - INSERT SELECT

INSERT SELECT 명령은 SELECT 명령의 결과를 지정한 테이블에 전부 추가한다. -> 데이터의 복사나 이동을 할 때 자주 사용한다.



## 상관 서브쿼리

`EXISTS` 술어를 사용하면 서브쿼리가 반환하는 결괏값이 있는지를 조사할 수 있다.

EXISTS 술어에 서브쿼리를 지정하면 서브쿼리가 행을 반환할 경우에 참을 돌려준다. 결과가 한 줄이라도 그 이상이라도 참이 된다.

`NOT EXISTS` - 행이 존재하지 않는 상태가 참이 된다.

부모 명령과 자식인 서브쿼리가 특정 관계를 맺는 것을 `상관 서브쿼리`라고 한다.

상관 서브쿼리에서는 부모 명령과 연관되어 처리되기 때문에 서브쿼리 부분만을 따로 뗴어내서 실행시킬 수 없다.

열이 어느 테이블의 것인지 명시적으로 나타낼 필요가 있다. -> 열명 앞에 '테이블명.' 붙이기

`IN` 을 사용하면 집합 안의 값이 존재하는지를 조사할 수 있다.

IN에서는 집합 안에 NULL 값이 있어도 무시하지는 않는다.



## 테이블 작성, 삭제, 변경

DDL - 데이터를 정의하는 명령. 스키마 내의 객체를 관리할 때 사용한다.

- CREATE TABLE

- DROP TABLE
  - 데이터 행 삭제
  
- ALTER TABLE

  - 열 추가, 삭제, 변경

  - NOT NULL 제약이 걸린 열을 추가할ㄷ 때는 기본값을 지정해야 한다.

    ```sql
    -- 열 추가
    ALTER TABLE 테이블명 ADD 새로운열
    
    -- 열 속성 변경
    ALTER TABLE 테이블명 MODIFY 열 정의
    
    -- 열 이름 변경
    ALTER TABLE 테이블명 CHANGE [기존 열 이름] [신규 열 정의]
    
    -- 열 삭제
    ALTER TABLE 테이블명 DROP 열명
    ```

  - **최대길이 연장** - 최대길이를 늘리는 경우는 많지만 줄이는 경우는 별로 없다.

  - **열 추가** - 시스템의 기능 확장 등의 이유

### 제약

기본키 제약, 외부참조(정합) 제약 등이 존재한다.

NOT NULL, UNIQUE - 열 제약

한 개의 제약으로 복수의 열에 제약을 설명하는 경우 - 테이블 제약

제약에 이름을 붙이면 나중에 관리하기가 쉬워지므로 가능한 한 이름을 붙이도록 한다. 제약 이름은 **CONSTRAINT 키워드**를 사용해서 지정한다.

제약 추가 - 열 제약 추가, 테이블 제약 추가

제약 삭제 - 열 제약 삭제, 테이블 제약 삭제

기본키로 지정할 열은 NOT NULL 제약이 설정되어 있어야 한다.

기본키는 테이블의 행 한 개를 특정할 수 있는 검색키이다. 

열을 기본키로 지정해 유일한 값을 가지도록 하는 구조가 기본키 제약이다. - 유일성 제약

기본키를 구성하는 열은 복수라도 상관없다.



## 인덱스

테이블에 붙여진 색인이라 할 수 있다.

인덱스의 역할은 **검색속도의 향상**이다.

인덱스에는 검색 시에 쓰이는 키워드와 대응하는 데이터 행의 장소가 저장되어 있다.

대부분의 데이터베이스에서는 테이블을 삭제하면 인덱스도 같이 삭제된다. - 테이블에 의존적이다.

인덱스에 쓰이는 검색 알고리즘 - 이진 탐색

인덱스를 작성할 때는 해당 인덱스가 어느 테이블의 어느 열에 관한 것인지 지정할 필요가 있다. 열은 복수로도 지정할 수 있다.

인덱스를 작성할 때는 저장장치에 색인용 데이터가 만들어진다. 테이블 크기에 따라 인덱스 작성시간도 달라진다. 행이 대량으로 존재하면 시간도 많이 걸리고 저장공간도 많이 소비한다.

INSERT 명령의 경우 인덱스를 최신 상태로 갱신하는 처리가 늘어나므로 처리속도가 조금 떨어진다.

인덱스를 사용해 검색하는지 확인 -> EXPLAIN 명령 사용



## 뷰

FROM 구에 기술된 서브쿼리에 이름을 붙이고 데이터베이스 객체화하여 쓰기 쉽게 한 것을 뷰라고 합니다.

서브쿼리 부분을 뷰로 대체하여 SELECT 명령을 간략하게 표현할 수 있다.

뷰를 사용함으로써 복잡한 SELECT 명령을 데이터베이스에 등록해 두었다가 나중에 간단히 실행할 수도 있다.

저장공간을 가지지 않는다.

테이블처럼 취급할 수 있다고는 해도 SELECT 명령에만 사용하는 것을 권장한다.

```sql
CREATE VIEW 뷰명 AS SELECT 명령
```

AS 키워드는 생략할 수 없다.

뷰의 약점

- 저장공간을 소비하지 않는 대신 CPU 자원을 사용한다.
- 뷰를 중첩해서 사용하는 경우에 처리 속도가 떨어지기 쉽다. -> Materialized View 사용하여 회피
- 뷰에 지정된 테이블의 데이터가 자주 변경되지 않는 경우라면 Materialized View를 사용하여 뷰의 약점을 어느 정도 보완할 수 있다.
- 함수 테이블을 사용하여 상관 서브커리처럼 동작할 수 있다.

