# 6장 데이터베이스 객체 작성과 작세

<br/>

## # 데이터베이스 객체

> 데이터베이스 객체란 테이블이나 뷰, 인덱스 등 데이터베이스 내에 정의하는 모든 것을 의미 

- 객체는 데이터베이스 내에 실체를 가지는 어떤 것을 의미한다. ( = 테이블,, )

- 객체는 이름을 가진다.

  - 기존 이름이나 예약어와 중복하지 않는다.
  - 숫자로 시작할 수 없다.
  - 언더스코어(_) 이외의 기호는 사용할 수 없다.
  - 한글을 사용할 때는 \` (백쿼트), "(더블쿼트)로 둘러싼다.
  - 시스템이 허용하는 길이를 초과하지 않는다.

  → 어떤 데이터가 저장되어 있는지 파악하는 기준이 되므로 **의미없는 이름을 붙이지 않도록 한다!**


### # 스키마 

> 데이터베이스 객체는 스키마라는 그릇 안에 만들어짐 

- 객체의 이름이 같아도 스키마가 서로 다르면 상관없다.
- 데이터베이스 객체 = **스키마 객체** 
- 데이터베이스에 테이블을 작성해서 구축해나가는 작업 = **스키마 설계** 
- 스키마는 SQL 명령의 **DDL**을 이용하여 정의
- **`CREATE DATABASE`** 명령으로 스키마 생성

→ 테이블과 스키마는 각각의 그릇 안에서 중복하지 않은 이름을 지정하여 이름이 충돌하지 않도록 기능하는 '네임스페이스'라고 부른다.


<br/>


## # 테이블 작성 & 삭제 & 변경

```sql
CREATE TABLE 테이블명 (열 정의1, 열 정의2, ...)
DROP TABLE 테이블명
ALTER TABLE 테이블명 하부명령
```

- **DDL은 데이터를 정의하는 명령**으로, 스키마 내의 객체를 관리할 때 사용

#

### # 테이블 작성

> CREATE TABLE 명령으로 테이블을 작성(생성)할 수 있다.

```sql
CREATE TABLE 테이블명 (
  열 정의1,	-- 열을 콤마(,)로 구분하여 연속으로 지정할 수 있음
  열 정의2,
  ...
)
```

```sql
열명 자료형 [DEFAULT 기본값][NULL|NOT NULL]
```

1. 명명규칙에 맞게 테이블명과 열명의 이름 지정
2. INTEGER 나 VARCHAR 등으로 자료형 지정
3. DEFAULT 로 기본값 설정 가능(단, 자료형에 맞는 리터럴로)[16강-4 참고]
4. 열이 NULL을 허용할 것인지 지정 [16강-3 참고]

#

### # 테이블 삭제 

> DROP TABLE 명령으로 테이블을 삭제할 수 있다.

```sql
DROP TABLE 테이블명 
```


#### # 데이터 행 삭제

- DELETE 명령에 WHERE 조건을 사용하여 조건에 맞는 데이터만 삭제
- DELETE 명령만 사용한다면 테이블은 삭제되지 않고 모든 데이터가 삭제
- DELETE 명령은 행 단위로 여러 가지 내부처리가 일어나기 때문에 삭제할 행이 많으면 처리속도가 떨어지는데
  - 이런 경우 DDL로 분류되는 **TRUNCATE TABLE** 명령 사용

#

### # 테이블 변경 

> ALTER TABLE 명령으로 열의 구성을 변경할 수 있다.

```sql
ALTER TABLE 테이블명 변경명령 
```

#### # 열 추가

```sql
ALTER TABLE 테이블명 ADD 열 정의
```

- 열 이름과 자료형을 지정하고 필요에 따라 기본값과 NOT NULL 제약 지정(열 이름 중복❌)
- 새로 열을 추가하게 되면 기존에 있던 데이터행에는 NULL로 저장
- 기본값이 지정되어 있으면 기본값으로 저장
- NOT NULL 제약이 걸린 열을 추가할 경우 기본값 지정 

#### # 열 속성 변경

```sql
ALTER TABLE 테이블명 MODIFY 열 정의
```

- 열 이름은 변경할 수 없지만, 자료형이나 기본값 NOT NULL 제약 등의 속성은 변경 가능

#### # 열 이름 변경

```sql
ALTER TABLE 테이블명 CHANGE [기존 열 이름][신규 열 정의]
```

- 열 이름 뿐만 아니라 열 속성도 변경 가능
- Oracle에서는 열 이름을 변경할 경우 `RENAME TO` 하부 명령 사용 

#### # 열 삭제

```sql
ALTER TABLE 테이블명 DROP 열명
```

- 테이블에 존재하지 않는 열이 지정되면 에러

<br/>

## # 제약과 기본키(primary key)

> 테이블에 제약을 설정함으로써 저장될 데이터를 제한할 수 있다.

- NOT NULL 제약 이외에도 기본키(Primary key) 제약이나 외부 참조 제약 등이 있음.

#

### # 테이블 작성 시 제약 정의

```sql
CREATE TABLE sample (
  no INTEGER NOT NULL,  -- 열 제약
  email VARCHAR(50) NOT NULL UNIQUE,  -- 열 제약
  PRIMARY KEY(no). -- 테이블 제약 
);
```

- 열 제약 : 열에 대해 정의하는 제약
- 테이블 제약 : 한 개의 제약으로 복수의 열에 제약을 설명하는 경우 
- 제약에는 이름을 붙이면 나중에 관리하기 쉬움 (**CONSTRAINT** 키워드 사용)



### # 제약 추가

- [26강-3.테이블 변경] 에서 처럼 `ALTER TABLE 테이블명 [ADD|MODIFY] 열 정의 제약` 


#### # 제약 삭제

- [26강-3.테이블 변경] 에서 처럼\
  -  `ALTER TABLE 테이블명 MODIFY 열명 제약 ` (열 제약 삭제) 
  -  `ALTER TABLE 테이블명 DROP PRIMARY KEY ` (테이블 제약 삭제) 

#

### # 기본키(Primary key)

- **기본키** : 테이블의 행 한 개를 특정할 수 있는 검색키
  - 대량의 데이터에서 원하는 데이터를 찾아낼 때 키가 되는 요소를 지정해 검색하는 것
- 기본키로 설정된 열이 중복하는 데이터 값을 가지면 제약에 위반 !! 
- 기본키로 지정한 열은 NOT NULL 제약이 설정되어 있어햐 함

→ 기본키로 지정해 유일한 값을 가지도록 하는 구조가 바로 **기본키 제약**

→ 행이 유일성을 필요로 한다는 다른 의미에서 **유일성 제약**



#### # 복수의 열로 기본키 구성

- 기본키를 복수의 열로 구성 가능 

  →	키를 구성하는 모든 열을 사용해서 중복하는 값이 있는지 없는지 검사


<br/>


## # 인덱스 구조

> 테이블에 붙여진 색인 

- 인덱스의 역할은 검색속도의 향상
  - 검색(탐색) → SELECT 명령에 WHERE 구로 조건을 지정하고 그에 일치하는 행을 찾는 일련의 과정
- **인덱스의 구조** = 책의 목차나 인덱스
  - 데이터베이스의 인덱스에는 검색 시에 쓰이는 키워드와 대응하는 데이터의 행의 장소 저장
- 인덱스는 테이블과 별개로 독립된 데이터베이스 객체이지만, 테이블에 의존하는 객체
  - 그래서 테이블을 삭제하면 인덱스도 같이 삭제 

#


### # 검색에 사용하는 알고리즘

> 풀 테이블 스캔, 이진탐색, 이진트리

- **풀 테이블 스캔(full table scan)** : 인덱스가 지정되지 않은 테이블 검색

- **이진 탐색(binary search)** : 미리 정렬된 집합에서 집합을 반을 나누어 조사하는 방법

- **이진 트리(binary tree)** : 

  - 테이블에 인덱스를 작성하면 테이블 데이터와 별개로 인덱스용 테이블이 생성 

    → 이진 트리라는 데이터 구조로 작성됨

  - 이진 트리에는 중복하는 값 등록할 수 없음

<br/>


## # 인덱스 작성 & 삭제

> 인덱스는 데이터베이스 개체의 하나로 DDL을 사용해서 작성하거나 삭제 

#

### # 인덱스 작성

```sql
CREATE INDEX 인덱스명 ON 테이블명 (열명1, 열명2, ...)
```

- SQL Server나 MySQL에서 인덱스는 **테이브 내의 객체가 되기** 때문에 테이블 내에 **이름이 중복되지 않도록** 지정해야함
- 인덱스를 작성할 때 해당 인덱스가 **어느 테이블의 어느 열**에 관한 것인지 지정할 필요가 있음

#

### # 인덱스 삭제

```sql
DROP INDEX 인덱스명 -- 스키마 객체의 경우
DROP INDEX 인덱스명 ON 테이블명	-- 테이블 내 객체의 경우
```

- 인덱스는 테이블에 의존하는 객체이기 때문에 테이블을 삭제하면 테이블에 작성된 인덱스도 자동으로 삭제! 



#### # SELECT 명령에서의 인덱스 사용

```sql
CREATE INDEX Insample on sample(a); -- a 열에 대한 인덱스 생성
SELECT * FROM sample where a = 'a'; -- WHERE 구에 a 열에 대한 조건식 사용하면 인덱스를 사용하여 빠르게 검색 가능
```

#

### # EXPLAIN

> 실제로 인덱스를 사용해 검색하는지를 확인하려면 EXPLAIN 명령 사용 

```sql
EXPLAIN SQL 명령
```

- EXPLAIN 뒤에 확인하고 싶은 SELECT 명령 등의 SQL 명령 지정
- 어떤 상태로 실행되는지를 데이터베이스가 설명해줄 뿐, 실제로 실행되는 건 ❌

<br/>

## # 뷰 작성 & 삭제

> **뷰(VIEW)** = FROM 구에 기술된 서브쿼리에 이름을 붙이고 데이터베이스 객체화하여 쓰기 쉽게 한 것 

#

### # 뷰

> 데이터베이스 객체로 등록할 수 없는 SELECT 명령을, 객체로서 이름을 붙여 관리할 수 있도록 한 것 

- 뷰는 SELECT 명령을 기록하는 데이터베이스 객체
- 뷰를 참조하면 그에 정의된 SELECT 명령의 실행결과를 테이블처럼 사용 가능
- **서브쿼리 부분을 뷰로 대체**하여 SELECT 명령을 간략하게 표현 가능 
- 복잡한 SELECT 명령을 데이터베이스에 등록해 두었다가 나중에 간단히 실행 가능

→ 자주 사용하거나 복잡한 SELECT 명령을 뷰로 만들어 편리하게 사용할 수 있다!!!! 



#### # 가상 테이블 

> '실체가 존재하지 않는다'라는 의미로 가상 테이블이라 불리기도 한다.

- 뷰는 테이블처럼 데이터를 쓰거나 지울 수 있는 저장공간을 가지지 않아 'SELECT 명령에서만 사용하는 것' 권장

#

### # 뷰 작성과 삭제

```sql
-- 뷰 작성
CREATE VIEW 뷰명 AS SELECT 명령
CREATE VIEW 뷰명(열명1, 열명2, ...) AS SELECT 명령

-- 뷰 삭제
DROP VIEW 뷰명
```

_더 알아보기_

#

### # 뷰의 약점

> 뷰는 데이터베이스 객체로서 저장장치에 저장되지만 SELECT 명령 만이 데이터베이스에 저장되기 때문에 테이블과 달리 대량의 저장공간을 필요로 하지 않는다. 저장공간을 소비하지 않는 대신 SELECT 명령은 계산능려을 필요로 하기 떄문에 CPU 자원을 사용한다.

#

#### # 머티리얼라이즈드 뷰(Materialized View)

###### #뷰의 약점 : 뷰의 근원이 되는 테이블에 보관하는 데이터양이 많은 경우 집계처리를 하거나 뷰를 중첩해서 사용하는 경우 처리속도가 많이 떨어진다.

- 머티리얼라이즈드 뷰를 사용하여 데이터를 일시적으로 저장해 사용하는 것이 아니라 테이블처럼 저장장치에 저장해두고 사용
  - 기존 뷰는 데이터를 일시적으로 저장했다가 쿼리가 실행 종료될 때 함께 삭제
- 처음 참조되었을 때 데이터를 저장한 후 다시 참조할 때 이전에 저장해 두었던 데이터를 그대로 사용
  - SELECT 명령을 매번 실행할 필요가 없음!
- 단, 변경사항이 있을 때 SELECT 명령을 재실행하여 데이터를 다시 저장해야하기 때문에 뷰에 지정된 데이터가 자주 변경되지 않는 경우 추천
- MySQL에서는 사용 불가,,, 

#

#### # 함수 테이블

###### # 뷰의 약점 : 뷰를 구성하는 SELECT 명령은 단독으로도 실행할 수 있어햐 한다. (연관이 있는 상관 서브쿼리 같은 경우 ❌ )

- 함수테이블은 테이블을 결괏값으로 반환해주는 사용자정의함수
- 함수에는 인수를 지정할 수 있기 때문에 인수의 값에 따라 WHERE 조건을 붙어 결괏값 변경 가능 
  - 그에 따라 상관 서브쿼리처럼 동작할 수 ⭕️

<br/>
