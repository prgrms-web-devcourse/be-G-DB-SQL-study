## 5장 - 반복문



**SQL에 반복문이 없는 이유**

- 반복문이 필요 없다고 생각했기 때문에 처음부터 제외됐다.

> 관계 조작은 관계 전체를 모두 조작의 대상으로 삼는다. 이러한 거의 목적은 반복을 제외하는 것이다. 최종 사용자의 생산성을 생각하면 이러한 조건을 만족해야 한다. 그래야만 응용 프로그래머의 생산성에도 기여할 수 있다.



**내부적으로 반복문 사용**

1. 하나의 레코드마다 작은 SQL을 사용해 접근한다.

2. 비즈니스 로직은 호스트언어에서 반복 처리를 구현한다.



- 반복문을 사용하는 장점이 크다면 반복문을 쓰는게 좋다.
- SQL을 적용하기 힘든 작업에 무리하게 SQL을 사용할 필요도 없다.



***하지만, 큰 단점이 있다.***





## 반복계의 공포

- 반복계에서 사용하는 SQL 문장은 단순하다.

- SQL을 잘 모르더라도 사용할 수 있다.



**포장계**

- 여러 행을 한꺼번에 처리하는 SQL
- 비즈니스 로직을 SQL에 넣으려다 보니 유지 보수성이 떨어질 수 있다.



### 반복계의 단점

- 성능이 좋지 않다.
- 반복계는 포장계로 구현한 코드에 완벽하게 진다.



![반복문 | print(&#39;yongineer&#39;)](https://yongineer.duckdns.org/sql/095.png)

- 레코드 수가 적으면 상관없지만, 레코드 수가 많아질수록 차이가 벌어진다.
- 반복계 처리시간 : **'처리 횟수 * 한 회에 걸리는 처리 시간'**

- 포장계는 인덱스를 사용한 접근이고, 실행 계획 변동이 없다면 대부분 완만한 커브를 그린다.



**SQL 실행의 오버 헤드**

- 오버헤드 : 계약을 하는 과정
  - 비용이 얼마나 들어갈지 모르고, 같은 규모의 일을 할 때 작은 일거리 100개를 하는 것보다 큰 일거리 한 개를 하는 것을 선호한다.



- SQL 실행할 때는 SQL 처리 이외에도 아래와 같은 다양한 처리가 이루어진다.
- 전처리
  - SQL 구문을 네트워크로 전송
  - 데이터베이스 연결
  - **SQL 구문 파스**
  - **SQL 구문의 실행 계획 생성 또는 평가**
- 후처리
  - 결과 집합을 네트워크로 전송



**SQL 구문 파스**

- 종류에 따라 느린 부분은 0.1초 ~ 1초 정도 걸린다.
- 데이터베이스가 SQL을 받을 때마다 실행된다.
- 반복계는 SQL을 여러번 실행하기 때문에 오버헤드가 높아질 수 밖에 없다.



**병렬 분산이 힘들다**

- 반복계는 반복 1회마다 처리를 단순화해서 리소스를 순산해서 병렬 처리하는 최적화가 안된다.



**데이터베이스의 진화로 인한 혜택을 받을 수 없다**

- DBMS는 **대규모 데이터를 다루는 복잡한 SQL 구문**을 **빠르게 하기 위해** 연구한다.
- 그래서 미들웨어 또는 하드웨어의 진화에 따른 혜택을 거의 받을 수 없다.





## 반복계를 빠르게 만드는 방법

**반복계를 포장계로 다시 작성**

- 애플리케이션 수정
- 실제 상황에서는 사용할 수 없는 경우가 많다.



**각각의 SQL을 빠르게 수정**

- SQL 구문이 단순하기 때문에 튜닝 가능성이 제한된다.



**다중화 처리**

- 리소스 여유가 있고, 처리를 나눌 수 있는 키가 명확하게 정해져 있다면 처리를 다중화해서 성능을 선형에 가깝게 변경할 수 있다.
- 처음부터 다중도를 설정할 수 있게 애플리케이션을 구성했다면 코드를 변경하지 않고도 확장할 수 있지만, 아니라면 사용할 수 없다.





## 반복계의 장점

**실행 계획의 안정성**

- 실행 계획에 변동 위험이 거의 없다.
- 실제 운용 중에 갑자기 실행 계획이 바뀌어 느려지는 현상은 일어나지 않는다.



**예상 처리 시간의 정밀도**

- 반복계 처리 시간 = '한 번의 실행 시간 * 실행 횟수'
- 한 번의 실행 시간 : **0.1밀리 초 ~ 0.5초**

- SQL 구문은 미세한 조건의 차이로 수 배~수백 배 차이가 나기 때문에 정밀도가 높다.



**트랜잭션 제어가 편리**

- 트랜잭션의 정밀도를 미세하게 제어할 수 있다.
- 배치 중단 시 해당 지점 근처에서 다시 처리를 실행할 수 있다.
- 반대로, 포장계는 오류가 발생하면 처음부터 처리를 시작해야 한다.





## SQL에서 반복 표현

**CASE 식과 윈도우 함수**

- CASE 식 : 절차 지향형 언어에서 **IF-THEN-ELSE 구문에 대응**하는 기능

```mysql
INSERT INTO Sales2
SELECT company,
	   year,
	   sale,
	   CASE SIGN(sale - MAX(sale)
	   						OVER(PARTITION BY company
	   							ORDER BY year
	   							ROWS BETWEEN 1 PRECEDING
	   									AND 1 PRECEDING))
	   WHEN 0 THEN '='
	   WHEN 1 THEN '+'
	   WHEN -1 THEN '-'
	   ELSE NULL END AS var
FROM Sales;
```

- `SIGN` : 음수(-1), 양수(1), 0(0) 리턴 - 직전 연도와의 판매 변화를 알기 위해 사용
- `ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING` : 현재 레코드에서 직전의 1개의 레코드를 선택 

- p.164의 반복문보다 훨씬 간결하다.
- 상관 서브쿼리로는 만들기 힘들다.



**최대 반복 횟수가 정해진 경우**

- 절차 지향적 사고방식으로 반복을 사용하면 레코드 수가 많아질수록 성능 측면에서 좋지 않다.

- CASE WHEN 구를 사용해 n회 반복을 n회 CASE 식 분기로 변환할 수 있다.

- 이 과정에서 테이블 스캔이 여러번 발생한다면 윈도우 함수를 사용해 줄일 수 있다. 
- 하지만, 정렬이 추가로 사용된다면 비용이 추가되기 때문에 테이블 크기가 크다면 테이블 풀 스캔을 줄이는 것의 효과가 더 클 수 있다.



**반복 횟수가 정해지지 않은 경우**

- 횟수의 상한이 정해지지 않았다면 일일이 분기로 변경할 수 없다.
- 재귀 공통 테이블 식을 사용해 계층 구조를 쉽게 찾을 수 있다.
- depth 필드를 기준으로 모든 레코드 탐색한다.

```mysql
WITH RECURSIVE Explosion (name, pcode, new_pcode, depth)
AS
(SELECT name, pcode, new_pcode, 1
	FROM PostalHistory
  WHERE name = 'A'
  	AND new_pcode IS NULL
UNION
SELECT Child.name, Child.pcode, Child.new_pcode, depth + 1
	FROM Explosion AS Parent, PostalHistory AS Child
WHERE Parent.pcode = Child.new_pcode
	AND Parent.name = Child.name)
```



**중첩 집합 모델**

- 각 레코드를 데이터의 집합으로 보고, 계층 구조를 집합의 중첩 관계로 나타내는 것이다.

- 재귀보다 빠를지 단순하게 판단할 수는 없지만, 엔티티 구조의 관점으로 문제를 해결할 수도 있다.





## 결론

- SQL은 절차 지향형을 탈출하기 위한 목적으로 설계된 언어다.
- 집합 지향의 사고방식을 가져야 한다.
