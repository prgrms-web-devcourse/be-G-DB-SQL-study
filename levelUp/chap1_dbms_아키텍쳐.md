

### 체크 포인트

- DB는 다양한 **트레이드 오프의 균형**을 잡으려는 미들웨어
- 처리 계속성
- 실행계획 : '목표'하는 데이터를 실행 가능한 '절차'로 바꾸는 과정

</br>

# DBMS 아키텍처



<img src="https://user-images.githubusercontent.com/33947168/129650664-1f87e3cc-6b8c-45c9-b1c5-e87b8f58b70c.png" alt="Untitled" style="zoom:67%;" />

</br>

### 쿼리 평가 엔진

- 계획을 세우고 실행하는 DBMS 핵심 기능을 담당하는 모듈
- SQL 구문 분석
- 실행계획 결정

</br>

### 버퍼 매니저

- 버퍼(특별한 용도로 사용하는 메모리 영역) 영역을 관리
- 디스크 용량 매니저와 함께 연동하여 작동

</br>

### 디스크 용량 매니저

- 데이터를 어디에 어떻게 저장할지 관리
- 데이터의 읽고 쓰기를 제어

</br>

### 트랜잭션 매니저 & 락 매니저

- 트랜잭션(각각의 데이터 처리 요청의 단위) 정합성을 유지 & 실행
- 필요시 데이터에 락을 걸어 다른 사람의 요청을 대기시킴

</br>

### 리커버리 매니저

- 데이터를 정기적으로 백업하고 장애 발생시 복구

</br>

</br>

# DBMS와 버퍼

point : 저장소의 느림을 어떻게 보완할 것인가?

</br>

### 영속성(기억비용) vs 속도

<img src="https://user-images.githubusercontent.com/33947168/129650983-3192d9c1-9739-4e24-9be0-3aebf4dca2a6.png" alt="Untitled (1)" style="zoom:67%;" />

- 하드 디스크 : 용량, 비용, 성능적인 면에서 큰 단점X
- 메모리 : 빠르지만 비싸다

</br>

### 버퍼 / 캐시 (Buffer / Cache)

- 자주 사용하는 데이터를 메모리 위에 올려둔다면, 곧바로 메모리에서 데이터를 읽어 빠르게 검색 가능
- 버퍼 매니저 : 버퍼에 '데이터를 어떻게 어느정도의 기간 동안 올릴지'를 관리

</br>

### 데이터 캐시

<img src="https://user-images.githubusercontent.com/33947168/129651003-b5e97ba1-163d-4dd0-81be-aa511322565d.png" alt="Untitled (2)" style="zoom:67%;" />

- 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역

- 데이터를 읽을 때 먼저 버퍼캐시에 적재하고나서 읽는다

- cf) 버퍼 캐시 히트율 (Buffer Cach Hit Ratio, BCHR) 과 SQL 성능

  읽은 전체 블록 중에서 물리적인 디스크 I/O를 수반하지 않고 곧바로 메모리에서 찾은 비율

</br>
  
#### BCHR

  = ( 캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수 ) * 100

  = ( (논리적 I/O - 물리적 I/O) /  논리적 I/O ) * 100

  = ( 1 - (물리적 I/O) / (논리적 I/O) ) * 100

  물리적 I/O = 논리적 I/O * (100 - BCHR)

  → 물리적 I/O가 성능을 결정하지만, 실제 SQL 성능을 향상하려면 논리적 I/O를 줄여야 한다

  = 논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것 = SQL 튜닝

</br>

### 로그 버퍼

- 갱신 SQL 구문의 **비동기 처리**를 도와 성능향상

- 데이터 캐시에 비해 로그 버퍼의 초깃값이 굉장히 작다 ex) 1MB

  → DB는 기본적으로 **검색**을 메인으로 처리한다고 가정하기 때문

과정

갱신과 관련된 SQL구문을 일단 로그버퍼로 보냄

→ 사용자에게는 해당 SQL구문이 '끝났다'고 통지

→ 이후 디스크에 변경 수행

</br>

### 메모리의 휘발성

- 메모리에는 데이터 영속성X. 전원을 끄면 메모리의 데이터가 사라져버림

- 문제점) 로그 버퍼 위에 존재하는 데이터가 반영되기 전에 장애가 발생해버리면??

  해당 데이터가 완전히 사라져서 복구조차 불가능!

→ **커밋 Commit**

- 커밋 시점에 반드시 갱신 정보를 로그파일(영속적인 저장소에 존재)에 기록

- 커밋 시점에 디스크 동기접근이 발생

  [여전한 문제점 : 데이터 정합성과 성능의 트레이드 오프](https://www.notion.so/9af643cd4c2a4a54aa193173d3b43856)

</br>

### 워킹 메모리 Working Memory

- 정렬 또는 해시 관련 처리에 사용되는 작업용 영역

  - 정렬 : ORDER BY 구, 집합 연산, 윈도우 함수 등의 기능을 실행 할 때
  - 해시 : 테이블 등의 결합에서 해시 결합이 사용되는 때

- 작업이 종료되는 해제되는 임시 영역

- 워킹 메모리 영역이 다루려는 데이터 양보다 작아 부족해지면, 대부분의 DBMS가 저장소를 사용

  (OS의 swap 영역 처럼)

  → 느려짐!! but, **처리 계속성**을 담보

  그래도 어떻게든 끝까지 처리하려고 노력하는 것!

</br>

</br>

# DBMS와 실행계획

### 권한 이양

- SQL: 절차(How)가 아닌 대상(What)을 기술하는 언어

  절차에 대한 결정은 DBMS에 맡김

- 장점 : 비즈니스 전체의 생산성

- 단점 : 성능을 향상 시키려면 결국 내부 절차를 들여댜봐야 함

<img src="https://user-images.githubusercontent.com/33947168/129651005-9321eb46-d2f3-4adf-bbd7-53e3277f27a0.png" alt="Untitled (3)" style="zoom:50%;" />

</br>

### 파서 Parser

- SQL 구문을 분석.
- 문법이 올바른지, 테이블이 존재하는 지 등을 확인
- SQL구문을 정형적인 형식으로 변환 = 후속 처리 효율화

</br>

### 옵티마이저 Optimizer

- 데이터 접근법(실행계획)의 최적화
- DBMS 두뇌의 핵심
- 과정
  - 선택 가능한 많은 실행 계획을 작성
    - 카탈로그 매니저가 제공하는 데이터를 바탕으로 함
    - 인덱스 유무, 데이터 분산/편향 정도, DBMS 내부 매개변수 등의 조건을 고려
  - 비용 연산
  - 가장 낮은 비용을 가진 실행계획을 선택

</br>

### 카탈로그 매니저 Catalog Manager

- 옵티마이저에게 중요한 정보를 제공

- 카탈로그(= 통계정보)

  - DBMS의 내부 정보를 모아놓은 테이블

  - 테이블 또는 인덱스의 통계 정보가 저장되어 있음

    ex) 각 테이블의 레코드 수, 필드 수, 필드 크기, 필드의 카디널리티(값의 개수), 인덱스 정보 등

</br>

### 플랜 평가 Plan Evaluation

- 옵티마이저가 세운 여러개의 실행 계획을 받아 최적의 실행 결과를 선택
- DBMS가 바로 실행할수 있는 코드가 아닌, 문자 그대로의 '실행 계획서'
- 사람이 읽고 수정 방안을 고려할 수 있음

</br>

### 옵티마이저와 카탈로그(=통계정보)

- 카탈로그 정보가 테이블 또는 인덱스의 실제와 일치하지 않을 수 있음

→ 테이블의 데이터가 많이 바뀌면(ex. 배치) 카탈로그의 통계 정보도 함께 갱신해야 함

  DBMS마다 다름

- 통계정보 갱신 또한 대상 테이블 또는 인덱스의 크기에 수에 따라서 몇십 분 ~ 몇 시간이 소요되기도 하는, 실행비용이 굉장히 높은 작업

</br>

</br>

# 실행계획 - SQL 구문의 성능을 결정

<img src="https://user-images.githubusercontent.com/33947168/129651014-2cace186-f93d-414a-82d4-cf65c3a5116f.png" alt="Untitled (4)" style="zoom:67%;" />

![Untitled (5)](https://user-images.githubusercontent.com/33947168/129651022-60d60e39-b859-44b0-bc9a-69bbe2fe175f.png)

</br>

### 테이블 풀 스캔(Full Scan)의 실행 계획

- 조작 대상 객체
- 객체에 대한 조작의 종류
- 조작 대상이 되는 레코드 수

</br>

### 인덱스 스캔의 실행계획

- 조작 대상이 되는 레코드 수
- 접근 대상 객체와 조작

</br>

### 간단한 테이블 결합의 실행 계획

- Nested Loop
- Sort Merge
- Hash

</br>

### 실행계획의 구조

- 일반적으로 트리 구조
- 중첩 단계가 깊을 수록 먼저 실행됨
- 같은 중첩 단계에서는 위에서 아래로 실행 됨

------

### 질문

Q. 실행계획 중첩 단계

Q. 소트 머지 : 결합키 정렬, 병합하면서 순차적으로 결합

정렬이 만약 이미 되어있다면 다시 정렬을 하는가?

Q. 로그 버퍼/ 데이터 캐시 나눈 이유?

Q. CQRS 패턴?

### 📌 다음 스터디

수요일, 1명, 2~3장